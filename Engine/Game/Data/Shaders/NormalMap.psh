sampler DiffuseSampler;sampler NormalSampler;sampler	SpecularSampler;sampler ShadowSampler;float3	gLightPosition		= float3(0.f, 0.f, 0.f);float3	gLightDirection		= float3(0.f, 0.f, 1.f);float3	gLightDiffuse		= float3(0.5f, 0.5f, 0.5f);float3	gLightSpecular		= float3(1.0f, 1.0f, 1.0f);float	gLightOutCos		= cos(3.14f / 4.f);float	gLightInCos			= cos(3.14f / 4.f);float3	gCamPosition		= float3(0.f.xxx);float gBumpCoef = 1.f;float gAmbientCoef = 1.f;struct PS_INPUT{	float2 UV				: TEXCOORD0;	float3 WorldPosition	: TEXCOORD1;	float3 WorldNormal		: NORMAL;	float3 Tangent			: TEXCOORD2;	float3 Binormal			: TEXCOORD3;	float3 ScreenUV			: TEXCOORD4;};float4 PSMain (PS_INPUT _Input)	: COLOR0{		const float AmbientCoef = 0.03f;	float	SpecularPower 		= 50.f;	_Input.WorldNormal = normalize(_Input.WorldNormal);	float3 DiffuseColor = tex2D(DiffuseSampler, _Input.UV).xyz;	float3 Bumps = gBumpCoef * (tex2D(NormalSampler, _Input.UV).xyz - (0.5f).xxx);	_Input.WorldNormal = normalize( _Input.WorldNormal + (Bumps.x * _Input.Tangent + Bumps.y * _Input.Binormal));	_Input.ScreenUV.xy /= _Input.ScreenUV.z;	_Input.ScreenUV.xy 	= (_Input.ScreenUV.xy + (1.f).xx) / (2.f).xx;	_Input.ScreenUV.y 	= 1.f - _Input.ScreenUV.y;	float ShadowCoef = tex2D(ShadowSampler, _Input.ScreenUV.xy).x;	float  DiffuseFactor  = 0.f;	float  SpecularFactor = 0.f;	float3 LightDir = normalize(gLightPosition - _Input.WorldPosition);	float LightPointDot = dot(-LightDir, gLightDirection);	float LDotN = dot(LightDir, _Input.WorldNormal);	if (LightPointDot >= gLightOutCos && LDotN > 0.f)	{				float AngleCoef = 1.f;		if (LightPointDot < gLightInCos)			AngleCoef = (LightPointDot - gLightOutCos) / (gLightInCos - gLightOutCos);		DiffuseFactor = LDotN * AngleCoef * ShadowCoef;		float3 CamDir = normalize(gCamPosition - _Input.WorldPosition);		float3 Reflect = normalize(2.f * LDotN * _Input.WorldNormal - LightDir);		SpecularFactor = min(pow(saturate(dot(Reflect, CamDir)), SpecularPower), tex2D(SpecularSampler, _Input.UV).x) * AngleCoef * ShadowCoef;	}	float4 FinalColor = float4(AmbientCoef * DiffuseColor + DiffuseFactor * gLightDiffuse * DiffuseColor + SpecularFactor * gLightSpecular * (DiffuseColor * 1.2f), 1.f);	if (ShadowCoef > 1.f)		FinalColor = float4( max (FinalColor.xyz * (-10.f), float3(1.f, 0.f, 0.f)), 1.f);	return FinalColor;}