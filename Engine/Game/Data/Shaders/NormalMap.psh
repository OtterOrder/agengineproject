sampler DiffuseSampler = sampler_state{    AddressU  = WRAP;        	AddressV  = WRAP;    MipFilter = LINEAR;    MinFilter = LINEAR;    MagFilter = LINEAR;};sampler NormalSampler = sampler_state{    AddressU  = WRAP;        	AddressV  = WRAP;    MipFilter = LINEAR;    MinFilter = LINEAR;    MagFilter = LINEAR;};float3	gLightPosition		= float3(0.f, 0.f, 0.f);float3	gLightDirection		= float3(0.f, 0.f, 1.f);float3	gLightDiffuse		= float3(0.5f, 0.5f, 0.5f);float3	gLightSpecular		= float3(1.0f, 1.0f, 1.0f);float3	gCamPosition		= float3(0.f.xxx);float	SpecularPower 		= 1.f;float	SpecularIntensity	= 1.f;float gBumpCoef = 1.f;struct PS_INPUT{	float2 UV				: TEXCOORD0;	float3 WorldPosition	: TEXCOORD1;	float3 WorldNormal		: NORMAL;	float3 Tangent			: TEXCOORD2;	float3 Binormal			: TEXCOORD3;};float4 PSMain (PS_INPUT _Input)	: COLOR0{		_Input.WorldNormal = normalize(_Input.WorldNormal);	float3 DiffuseColor = tex2D(DiffuseSampler, _Input.UV).xyz;	float3 Bumps = gBumpCoef * (tex2D(NormalSampler, _Input.UV).xyz - (0.5f).xxx);	_Input.WorldNormal = normalize( _Input.WorldNormal + (Bumps.x * _Input.Tangent + Bumps.y * _Input.Binormal));		float3 LightDir = normalize(gLightPosition - _Input.WorldPosition);	float  DiffuseFactor = dot(LightDir, _Input.WorldNormal);		float3 CamDir = normalize(gCamPosition - _Input.WorldPosition);	float3 Reflect = normalize(2.f * DiffuseFactor * _Input.WorldNormal - LightDir);	float  SpecularFactor = min(pow(saturate(dot(Reflect, CamDir)), SpecularPower*100.f), SpecularIntensity);		float4 FinalColor = float4(DiffuseFactor * gLightDiffuse * DiffuseColor + SpecularFactor * gLightSpecular, 1.f);		return FinalColor;}