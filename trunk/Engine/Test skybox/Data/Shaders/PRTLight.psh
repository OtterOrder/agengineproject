
sampler DiffuseSampler = 
sampler_state
{
    AddressU  = WRAP;        
	AddressV  = WRAP;
    MipFilter = LINEAR;
    MinFilter = LINEAR;
    MagFilter = LINEAR;
};

sampler NormalSampler = 
sampler_state
{
    AddressU  = WRAP;        
	AddressV  = WRAP;
    MipFilter = LINEAR;
    MinFilter = LINEAR;
    MagFilter = LINEAR;
};

samplerCUBE YlmCoeff0Sampler = 
sampler_state
{
    MipFilter = LINEAR;
    MinFilter = LINEAR;
    MagFilter = LINEAR;
    ADDRESSU = CLAMP;
    ADDRESSV = CLAMP;
};

samplerCUBE YlmCoeff4Sampler = 
sampler_state
{
    MipFilter = LINEAR;
    MinFilter = LINEAR;
    MagFilter = LINEAR;
    ADDRESSU = CLAMP;
    ADDRESSV = CLAMP;
};

samplerCUBE YlmCoeff8Sampler = 
sampler_state
{
    MipFilter = LINEAR;
    MinFilter = LINEAR;
    MagFilter = LINEAR;
    ADDRESSU = CLAMP;
    ADDRESSV = CLAMP;
};

samplerCUBE YlmCoeff12Sampler = 
sampler_state
{
    MipFilter = LINEAR;
    MinFilter = LINEAR;
    MagFilter = LINEAR;
    ADDRESSU = CLAMP;
    ADDRESSV = CLAMP;
};
float3  gTransmitColor;

float4   gLightCoeffsR[4];            // SH lighting coefficients
float4   gLightCoeffsG[4];            // SH lighting coefficients
float4   gLightCoeffsB[4];            // SH lighting coefficients

void BuildSHTransferVector(float4 vLDPRTCoeffs, float4 vSHCoeffs[4], out float4 vTransferVector[4]) 
{
    vTransferVector[0] = float4(vLDPRTCoeffs.x, vLDPRTCoeffs.y, vLDPRTCoeffs.y, vLDPRTCoeffs.y)*vSHCoeffs[0];
    vTransferVector[1] = float4(vLDPRTCoeffs.z, vLDPRTCoeffs.z, vLDPRTCoeffs.z, vLDPRTCoeffs.z)*vSHCoeffs[1];
    vTransferVector[2] = float4(vLDPRTCoeffs.z, vLDPRTCoeffs.w, vLDPRTCoeffs.w, vLDPRTCoeffs.w)*vSHCoeffs[2];
    vTransferVector[3] = float4(vLDPRTCoeffs.w, vLDPRTCoeffs.w, vLDPRTCoeffs.w, vLDPRTCoeffs.w)*vSHCoeffs[3];
} 

void Ylm(float3 vSHCoeffDir, out float4 vYlm[4]) 
{  
    vYlm[0] = texCUBE(YlmCoeff0Sampler,  vSHCoeffDir);
    vYlm[1] = texCUBE(YlmCoeff4Sampler,  vSHCoeffDir);
    vYlm[2] = texCUBE(YlmCoeff8Sampler,  vSHCoeffDir);
    vYlm[3] = texCUBE(YlmCoeff12Sampler, vSHCoeffDir);  
} 

//--------------------------------------------------------------------------------------
// 1 channel LDPRT, 3 channel lighting 
//--------------------------------------------------------------------------------------
float4 LDPRTCoeffLighting(float2 vTexCoord, float3 vSHCoeffDir) 
{
    float4 vExitRadiance[3] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
    float4 vTransferVector[4], vYlm[4];
    Ylm(vSHCoeffDir, vYlm);

    // A 4 channel texture can hold a cubics worth of LDPRT coefficients.
    float4 vLDPRTCoeffs = { 1,  2.0/3.0, 0.25, 0.01};
    BuildSHTransferVector(vLDPRTCoeffs, vYlm, vTransferVector);
    
    // Calculate sub-surface contribution
    
    // Negating the odd-order coefficients will mirror the lobe across the tangent plane
    vLDPRTCoeffs.y *= -1; 
    float4 vTransferVectorBehind[4];
    BuildSHTransferVector(vLDPRTCoeffs, vYlm, vTransferVectorBehind);
    
    // The alpha channel of the albedo texture is being used to store how 'thin'
    // the material is, where higher values allow more light to transmit.
    // Although each color channel could have a separate thickness texture, we're
    // simply scaling the amount of transmitted light by a channel scalar. 
    float4 vAlbedo = tex2D(DiffuseSampler, vTexCoord);
    for( int i=0; i < 4; i++ )
    {
        vTransferVectorBehind[i] *= vAlbedo.a;
    }

    // Red
    vExitRadiance[0] += gLightCoeffsR[0] * (vTransferVector[0] + gTransmitColor.r  * vTransferVectorBehind[0]);
    vExitRadiance[0] += gLightCoeffsR[1] * (vTransferVector[1] + gTransmitColor.r  * vTransferVectorBehind[1]);
    vExitRadiance[0] += gLightCoeffsR[2] * (vTransferVector[2] + gTransmitColor.r  * vTransferVectorBehind[2]);
    vExitRadiance[0] += gLightCoeffsR[3] * (vTransferVector[3] + gTransmitColor.r  * vTransferVectorBehind[3]);

    // Green
    vExitRadiance[1] += gLightCoeffsG[0] * (vTransferVector[0] + gTransmitColor.g  * vTransferVectorBehind[0]);
    vExitRadiance[1] += gLightCoeffsG[1] * (vTransferVector[1] + gTransmitColor.g  * vTransferVectorBehind[1]);
    vExitRadiance[1] += gLightCoeffsG[2] * (vTransferVector[2] + gTransmitColor.g  * vTransferVectorBehind[2]);
    vExitRadiance[1] += gLightCoeffsG[3] * (vTransferVector[3] + gTransmitColor.g  * vTransferVectorBehind[3]);

    // Blue
    vExitRadiance[2] += gLightCoeffsB[0] * (vTransferVector[0] + gTransmitColor.b  * vTransferVectorBehind[0]);
    vExitRadiance[2] += gLightCoeffsB[1] * (vTransferVector[1] + gTransmitColor.b  * vTransferVectorBehind[1]);
    vExitRadiance[2] += gLightCoeffsB[2] * (vTransferVector[2] + gTransmitColor.b  * vTransferVectorBehind[2]);
    vExitRadiance[2] += gLightCoeffsB[3] * (vTransferVector[3] + gTransmitColor.b  * vTransferVectorBehind[3]);

    return float4( dot(vExitRadiance[0], 1), 
                   dot(vExitRadiance[1], 1), 
                   dot(vExitRadiance[2], 1), 
                   1 );
} 

struct PS_INPUT
{
	float2 UV				: TEXCOORD0;
	float3 WorldPosition	: TEXCOORD1;
	float3 WorldNormal		: NORMAL;
	float3 Tangent			: TEXCOORD2;
	float3 Binormal			: TEXCOORD3;
};

float4 PSMain (PS_INPUT _Input)	: COLOR0
{
	// Albedo
    float4 Color = tex2D(DiffuseSampler, _Input.UV)/*float4(1.0f, 1.0f, 1.0f, 1.0f)*/;
	
	float3 Normal = tex2D(NormalSampler, _Input.UV);
	Normal = (Normal * 2) - 1;
	float3x3 mTangentFrame = {_Input.Tangent,_Input.Binormal, normalize(_Input.WorldNormal) };
    Normal = mul( Normal, mTangentFrame );
	
	Color *= LDPRTCoeffLighting( _Input.UV, Normal);
	return Color;
}